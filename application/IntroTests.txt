
// /*#include <glad/glad.h>
// #include <glfw3.h>
// 
// #include <iostream>
// 
// const char* vertexShaderSource =	"#version 330 core\n"
// 									"layout (location = 0) in vec3 aPos;\n"
// 									"void main() {\n"
// 									"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);"
// 									"}\0";
// 
// const char* fragmentShaderSource =	"#version 330 core\n"
// 									"out vec4 FragColor;\n"
// 									"void main() {\n"
// 									"	FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);"
// 									"}\0";
// 
// 
// const char* blackFragmentShaderSource =	"#version 330 core\n"
// 										"out vec4 FragColor;\n"
// 										"void main() {\n"
// 										"	FragColor = vec4(0.1f, 1.0f, 0.1f, 1.0f);"
// 										"}\0";
// 
// 
// 
// const char* whiteFragmentShaderSource =	"#version 330 core\n"
// 										"out vec4 FragColor;\n"
// 										"void main() {\n"
// 										"	FragColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);"
// 										"}\0";
// 
// 
// const char* fragmentShader1Source = "#version 330 core\n"
// "out vec4 FragColor;\n"
// "void main()\n"
// "{\n"
// "   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
// "}\n\0";
// const char* fragmentShader2Source = "#version 330 core\n"
// "out vec4 FragColor;\n"
// "void main()\n"
// "{\n"
// "   FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"
// "}\n\0";
// 
// 
// /*----------------------GLFW Callbacks--------------------------------------------------------------------------------*/
// 
// // Callback that allows resizing the window to update dimensions
// void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
// 	// first two params is lower left corner of viewport (openGL 0 bot Y axis?)
// 	glViewport(0, 0, width, height);
// }
// 
// void processInput(GLFWwindow* window) {
// 	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
// 		glfwSetWindowShouldClose(window, true);
// 	}
// }
// 
// /*----------------------GLFW Callbacks--------------------------------------------------------------------------------*/
// 
// int main2() {
// 
// 	/*----------------------GLFW Initialization---------------------------------------------------------------------------*/
// 
// 	glfwInit();
// 
// 	// Configures GLFW, first param is what we want to configure
// 	// 3 is the value we set for the option
// 	// http://www.glfw.org/docs/latest/window.html#window_hints
// 	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // Sets up what version of open GL we are using. Stands for 3.0
// 	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // Sets up what version of open GL we are using. Stands for 0.3
// 	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Tells GLFW we only want to use core-profile
// 	//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPACT, GL_TRUE); // This is required for macOS to remove backwards compatability 
// 
// 	/*----------------------GLFW Initialization---------------------------------------------------------------------------*/
// 	/*--------------------------------------------------------------------------------------------------------------------*/
// 	/*----------------------Create a window object------------------------------------------------------------------------*/
// 
// 	GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", NULL, NULL); // jnote should use nullptr?
// 
// 	if (window == NULL) { // jnote should use nullptr? Maybe cant because C bindings?
// 		std::cout << "Failed to create GLFW window\n";
// 		glfwTerminate();
// 		return -1;
// 	}
// 
// 	glfwMakeContextCurrent(window);
// 
// 	/*----------------------Create a window object------------------------------------------------------------------------*/
// 	/*--------------------------------------------------------------------------------------------------------------------*/
// 	/*----------------------GLAD Initialization---------------------------------------------------------------------------*/
// 
// 	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
// 		std::cout << "Failed to initialize GLAD\n";
// 		return -1;
// 	}
// 
// 	/*----------------------GLAD Initialization---------------------------------------------------------------------------*/
// 	/*--------------------------------------------------------------------------------------------------------------------*/
// 	/*----------------------Hello Triangle--------------------------------------------------------------------------------*/
// 
// 
// 	/*
// 	float vertices[] = {
// 		-0.5f, -0.5f,  0.0f,
// 		 0.5f, -0.5f,  0.0f,
// 		 0.0f,  0.5f,  0.0f
// 	};
// 
// 	unsigned int VBO; // id of the buffer
// 	glGenBuffers(1, &VBO); // buffer sends data to GPU
// 	glBindBuffer(GL_ARRAY_BUFFER, VBO); // bind our buffer to its target
// 
// 	// from here on any calls made to the GL_ARRAY_BUFFER are done to VBO
// 
// 	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // copy verts into bufer memory
// 
// 	*/
// 
// 
// 	// Create our Vertex Shader------------------------------------------------------------------
// 	unsigned int vertexShader;
// 	vertexShader = glCreateShader(GL_VERTEX_SHADER);
// 	// attach source
// 
// 	int vertSuccess;
// 	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &vertSuccess);
// 	if (!vertSuccess) {
// 		char infoLog[512];
// 		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
// 		std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
// 	}
// 
// 
// 	// Create our Fragment Shader----------------------------------------------------------------
// 	/*
// 	unsigned int fragmentShader;
// 	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
// 	glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
// 	glCompileShader(fragmentShader);
// 
// 	int fragSuccess;
// 	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &fragSuccess);
// 	if (!fragSuccess) {
// 		char infoLog[512];
// 		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
// 		std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
// 	}
// 	*/
// 	// Create shader program---------------------------------------------------------------------
// 	/*
// 	unsigned int shaderProgram;
// 	shaderProgram = glCreateProgram();
// 	
// 	// attach shaders
// 	glAttachShader(shaderProgram, vertexShader);
// 	glAttachShader(shaderProgram, fragmentShader);
// 	glLinkProgram(shaderProgram); // links shaders
// 
// 	int progSuccess;
// 	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &progSuccess);
// 	if (!progSuccess) {
// 		char infoLog[512];
// 		glGetProgramInfoLog(fragmentShader, 512, NULL, infoLog);
// 		std::cout << "ERROR::SHADER::PROGRAM::COMPILATION_FAILED\n" << infoLog << std::endl;
// 	}
// 	*/
// 
// 	// attach shaders
// 
// 	unsigned int whiteShader = glCreateShader(GL_FRAGMENT_SHADER);
// 	unsigned int blackShader = glCreateShader(GL_FRAGMENT_SHADER);
// 	unsigned int whiteShaderProgram = glCreateProgram();
// 	unsigned int blackShaderProgram = glCreateProgram();
// 	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
// 	glCompileShader(vertexShader);
// 	glShaderSource(whiteShader, 1, &fragmentShader2Source, NULL);
// 	glCompileShader(whiteShader);
// 	glShaderSource(blackShader, 1, &fragmentShader1Source, NULL);
// 	glCompileShader(blackShader);
// 	glAttachShader(whiteShaderProgram, vertexShader);
// 	glAttachShader(whiteShaderProgram, whiteShader);
// 	glLinkProgram(whiteShaderProgram); // links shaders
// 	glAttachShader(blackShaderProgram, vertexShader);
// 	glAttachShader(blackShaderProgram, blackShader);
// 	glLinkProgram(blackShaderProgram); // links shaders
// 
// 
// 
// 	//unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
// 	unsigned int fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER); // the first fragment shader that outputs the color orange
// 	unsigned int fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER); // the second fragment shader that outputs the color yellow
// 	unsigned int shaderProgramOrange = glCreateProgram();
// 	unsigned int shaderProgramYellow = glCreateProgram(); // the second shader program
// 	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
// 	glCompileShader(vertexShader);
// 	glShaderSource(fragmentShaderOrange, 1, &whiteFragmentShaderSource, NULL);
// 	glCompileShader(fragmentShaderOrange);
// 	glShaderSource(fragmentShaderYellow, 1, &blackFragmentShaderSource, NULL);
// 	glCompileShader(fragmentShaderYellow);
// 	// link the first program object
// 	glAttachShader(shaderProgramOrange, vertexShader);
// 	glAttachShader(shaderProgramOrange, fragmentShaderOrange);
// 	glLinkProgram(shaderProgramOrange);
// 	// then link the second program object using a different fragment shader (but same vertex shader)
// 	// this is perfectly allowed since the inputs and outputs of both the vertex and fragment shaders are equally matched.
// 	glAttachShader(shaderProgramYellow, vertexShader);
// 	glAttachShader(shaderProgramYellow, fragmentShaderYellow);
// 	glLinkProgram(shaderProgramYellow);
// 
// 
// 	// cleanup
// 	glDeleteShader(vertexShader);
// 	//glDeleteShader(fragmentShader);
// 	glDeleteShader(blackShader);
// 	glDeleteShader(whiteShader);
// 
// 	/*
// 
// 	// Usage -------------------------------------------------------------------------------------
// 	glUseProgram(shaderProgram); // every render and shader call from here on our will use this program object
// 
// 	// how should openGL interpret vertex data
// 	// 1st param is the vertex attribute we want to configure. Aka "location = 0" in vert shader
// 	// 2nd param is size of data, vec3 = 3 pieces of data
// 	// 3rd param is the type of data. vec* in GLSL is floating point values
// 	// 4th param is if we normalize the data
// 	// 5th is the stride. Aka space between consecutive verts. Can set to 0 to let openGL determine which only works with tight packing
// 	// 6th is position data being point in buffer.
// 	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
// 	glEnableVertexAttribArray(0);
// 	*/
// 
// 	/* first triangle :(
// 	float vertices[] = {
// 		-0.5f, -0.5f,  0.0f,
// 		 0.5f, -0.5f,  0.0f,
// 		 0.0f,  0.5f,  0.0f
// 	};
// 	*/
// 	/* first square 
// 	float vertices[] = {
// 		 0.5f,  0.5f,  0.0f,
// 		 0.5f, -0.5f,  0.0f,
// 		-0.5f, -0.5f,  0.0f,
// 		-0.5f,  0.5f,  0.0f
// 	};
// 
// 	unsigned int indices[] = {
// 		0, 1, 3,
// 		1, 2, 3
// 	};
// 	*/
// 
// 	/* exercise 1 */
// 
// 	float vertices[] = {
// 		-0.5f,   0.5f,   0.0f,
// 		-0.25f,  0.5f,   0.0f,
// 		-0.5f,   0.0f,   0.0f,
// 		 0.25f,  0.25f,  0.0f,
// 		 0.25f, -0.0f,   0.0f,
// 		-0.0f,   0.25f,  0.0f
// 	};
// 
// 	unsigned int indices[] = {
// 		0, 1, 2,
// 		3, 4, 5
// 	};
// 
// 
// 	float firstTriangle[] = {
// 		-0.5f,   0.5f,   0.0f,
// 		-0.25f,  0.5f,   0.0f,
// 		-0.5f,   0.0f,   0.0f
// 	};
// 
// 	float secondTriangle[] = {
// 		 0.25f,  0.25f,  0.0f,
// 		 0.25f, -0.0f,   0.0f,
// 		-0.0f,   0.25f,  0.0f
// 	};
// 
// 	// Generate Vertex Array Object---------------------------------------------------------------
// 	//unsigned int VAO;
// 	//unsigned int VBO;
// 	//unsigned int EBO;
// 	//glGenBuffers(1, &VBO);
// 	//glGenBuffers(1, &EBO);
// 	//glGenVertexArrays(1, &VAO);
// 	unsigned int VAOs[2];
// 	unsigned int VBOs[2];
// 	glGenBuffers(2, VBOs);
// 	glGenVertexArrays(2, VAOs);
// 
// 	// initialization (do once unless object frequently changes)
// 	// 1. bind Vertex Array Object
// 	glBindVertexArray(VAOs[0]);
// 	// 2. copy out vert array in a buffer for OpenGL to use
// 	glBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);
// 	glBufferData(GL_ARRAY_BUFFER, sizeof(firstTriangle), firstTriangle, GL_STATIC_DRAW);
// 
// 	//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
// 	//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
// 	// 3. then set our vertex attributes pointers
// 	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
// 	glEnableVertexAttribArray(0);
// 
// 
// 
// 	glBindVertexArray(VAOs[1]);
// 	glBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);
// 	glBufferData(GL_ARRAY_BUFFER, sizeof(secondTriangle), secondTriangle, GL_STATIC_DRAW);
// 	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
// 	glEnableVertexAttribArray(0);
// 
// 
// 	/// I dont understand the rest of this since it wasnt covered, leaving this here to go over later
// 	// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind
// 	glBindBuffer(GL_ARRAY_BUFFER, 0);
// 
// 	// remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
// 	//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
// 
// 	// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other
// 	// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.
// 	glBindVertexArray(0);
// 	/// end understanding issues
// 
// 
// 	// sets wireframe mode
// 	// glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
// 
// 	/*----------------------Hello Triangle--------------------------------------------------------------------------------*/
// 	/*--------------------------------------------------------------------------------------------------------------------*/
// 	/*----------------------Viewport Callback-----------------------------------------------------------------------------*/
// 
// 	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
// 
// 	/*----------------------Viewport Callback-----------------------------------------------------------------------------*/
// 	/*--------------------------------------------------------------------------------------------------------------------*/
// 	/*----------------------Render Loop-----------------------------------------------------------------------------------*/
// 
// 	int nrAttributes;
// 	glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
// 	std::cout << "Maximum nr of vertex attributes supported: " << nrAttributes << std::endl;
// 	while (!glfwWindowShouldClose(window)) { // checks at the start of each loop if GLFW has been told to close
// 		processInput(window);
// 
// 		//rendering 
// 
// 		glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // state setting
// 		glClear(GL_COLOR_BUFFER_BIT); // state using
// 
// 		// draw a triangle
// 		//glUseProgram(whiteShader);
// 		glUseProgram(whiteShaderProgram);
// 		glBindVertexArray(VAOs[0]);
// 		glDrawArrays(GL_TRIANGLES, 0, 3);
// 		glUseProgram(blackShaderProgram);
// 		glBindVertexArray(VAOs[1]);
// 		glDrawArrays(GL_TRIANGLES, 0, 3);
// 		//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
// 
// 		// Exercise 1
// 		//glDrawArrays(GL_TRIANGLES, 0, 6);
// 
// 		// glBindVertexArray(0);
// 
// 
// 		glfwSwapBuffers(window); // swaps the render buffers 
// 		glfwPollEvents(); // checks events 
// 	}
// 
// 	/*----------------------Render Loop-----------------------------------------------------------------------------------*/
// 	/*--------------------------------------------------------------------------------------------------------------------*/
// 	/*----------------------Cleanup---------------------------------------------------------------------------------------*/
// 
// 	glfwTerminate();
// 	return 0;
// }
// */